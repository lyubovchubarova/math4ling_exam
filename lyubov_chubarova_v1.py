from collections import deque
import random


def bfs(g, start):
	
	
	#бфс с улучшением -- помимо пути, он еще и находит кратчайшее растояние между стартовой вершиной
	# и всеми остальными вершинами в графе.
	
	#это хранится в массиве dist, который мы возвращаем из функции, так как этот массив нам понадобится
	dist = [100000000] * len(g)
	used = [0] * len(g)
	dist[start] = 0
	used[start] = 1
	
	q = deque()
	q.append(start)
	
	while len(q) > 0:
		v = q.popleft()
		
		for to in g[v]:
			if not used[to]:
				q.append(to)
				dist[to] = dist[v] + 1
				used[to] = 1
	
	
	return dist
		

def main():

	#считывание входных данных
	#считаем количество вершин графа и количество ребер графа, затем
	#считаем граф как набор ребер, затем построчно введем позиции героев, монстров,
	#вероятность шага монстра и конечную вершину
	n, m = map(int, input().split())
	g = [[] for i in range(n)]
	
	for i in range(m):
		x, y = map(int, input().split())
		g[x].append(y)
		g[y].append(x)
		
		
	heroes = list(map(int, input().split()))
	monsters = list(map(int, input().split()))
	
	p = float(input())
	finish = int(input())
	
	#запустим бфс для конечной вершины, итого у нас есть массив dist, в котором хранится длина кратчайшего пути
	#от конечной вершины до любой в графе, а так как у нас граф неориентированный, то расстояние от конечной вершины
	#до любой другой вершины V равняется расстоянию от V до конечной вершины

	dist_from_finish = bfs(g, finish)
	
	for v in heroes:
		#если до какой-то вершины с героем пути нет, то это значит, что он никогда не придет в конечную вершину
		if dist_from_finish[v] == 100000000:
			print('Impossible')
			return
			
			
	#основной цикл
	
	turn = 1
	while True:
		print('step#' + str(turn))
		turn += 1
		#это временный массив куда мы будем складывать новые позиции монстров, потому что изменять основной массив monsters -- трудоемко по времени
		#лучше мы сложим все новые позиции сюда, а затем просто скажем что monsters = newmonsters
		newmonsters = []
		
		for monster in monsters:
			
			#генерируем вероятность
			step = random.random()
			
			#если она меньше чем надо, то остаемся на месте и идем дальше по циклу
			if step < p:
				newmonsters.append(monster)
				continue
			
			#иначе перешаем список вершин куда может пойти монстр и пойдем в первую клетку, в которой нет героя
			#если такую клетку не найдем (за это будет отвечать переменная found) то монстру ничего не останется делать, 
			#как остаться в своей клетке
			random.shuffle(g[monster])
			
			found = False
			for pl in g[monster]:
				#если такой позиции нет в текущих позициях геров, то все ок, шагаем туда
				if pl not in heroes:
					found = True
					newmonsters.append(pl)
					break
			#если новую позицию не нашли, то оставляем старую
			if not found:
				newmonsters.append(monster)
		
		#переприсваиваем массив
		monsters = newmonsters
		
		
		#то же самое будем делать с героями (в плане создания нового массива позиций а затем его перепрсваивания)
		newheroes = []
		
		#эта строчка считает количество героев в массиве, позиция которых равна финишной
		#если это количество равно длине массива, то все герои пришли куда надо, можно завершать программу
		
		
		cnt = sum(list(1 for h in heroes if h == finish))
		if cnt == len(heroes):
			print('Done!')
			return
			
		#иначе идем по всем героям
		for h in heroes:
			
			#если он уже стоит в финишной позиции то пропустим его(нам нет смысла его двигать)
			if h == finish:
				continue
			
			#тут будем смотреть на его смежные вершины
			#если эта вершина лежит на кратчайшем пути и не занята монстром, то пойдем в нее
			#если такую вершину не найдем (за это опять же отвечает переменная found), то оставим героя в своей клетке
			found = False
			
			for pl in g[h]:
				if dist_from_finish[pl] == dist_from_finish[h] - 1 and pl not in monsters:
					found = True
					newheroes.append(pl)
					break
					
			if not found:
				newheroes.append(h)
				
		heroes = newheroes
# И можно пожалуйста попросить помнить что у нас было всего 6 или 7 лекций. каждая из которых бегло обозревала огромное множество алгоритмов на графах и всего две домашки на элементарные алгоритмы на графах. И наверное есть такая презумпция, что у всех должно быть более или менее одинаковое по сложности задание, а разброс сложности заданий и факт того, что условие сформулировано неоднозначно(хотя казалось бы, олимпиадная задача на графы) и на справедливые вопросы  по задаче не дается никаких ответов заставляет задуматься о том, что задание делалось на коленке за час до экзамена... Я абсолютно верю, что мои преподаватели могут написать игру на графах и это кажется им легким, спасибо, только вот от меня это требует каких-то абсолютно невыразимых усилий и применения знаний, которых не было в курсе. Первый вариант экзамена = задание из разряда "а изобрети велосипед"
						
					
			
		
	
		
		
	
